<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈平安</title>
  
  
  <link href="https://li199959.github.io/atom.xml" rel="self"/>
  
  <link href="https://li199959.github.io/"/>
  <updated>2023-04-04T03:27:46.863Z</updated>
  <id>https://li199959.github.io/</id>
  
  <author>
    <name>陈平安</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组会周报23230329</title>
    <link href="https://li199959.github.io/posts/ee703177.html"/>
    <id>https://li199959.github.io/posts/ee703177.html</id>
    <published>2023-04-04T06:47:59.677Z</published>
    <updated>2023-04-04T03:27:46.863Z</updated>
    
    
    <summary type="html">OFC一些文章的精读</summary>
    
    
    
    <category term="组会" scheme="https://li199959.github.io/categories/%E7%BB%84%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>nlp发展过程</title>
    <link href="https://li199959.github.io/posts/11e0345.html"/>
    <id>https://li199959.github.io/posts/11e0345.html</id>
    <published>2023-04-04T06:47:59.666Z</published>
    <updated>2023-03-29T09:05:06.526Z</updated>
    
    <content type="html"><![CDATA[<h1>nlp发展史</h1><p>​预训练过程，会大致说下NLP中的预训练技术是一步一步如何发展到Bert模型的，从中可以很自然地看到Bert的思路是如何逐渐形成的，Bert的历史沿革是什么，继承了什么，创新了什么，为什么效果那么好，主要原因是什么，以及为何说模型创新不算太大，为何说Bert是近年来NLP重大进展的<em>集大成者</em> 。我们一步一步来讲，而串起来这个故事的脉络就是自然语言的预训练过程，但是落脚点还是在Bert身上。要讲自然语言的预训练，得先从图像领域的预训练说起。</p><h2 id="1-预训练是什么">1.预训练是什么</h2><p>通过一个已经训练好的模型 A，去完成一个小数据量的任务 B（使用了模型 A 的浅层参数）</p><p>其中呢，任务 A 与任务 B 是相似的</p>]]></content>
    
    
    <summary type="html">文字展示</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql的增删改查用法</title>
    <link href="https://li199959.github.io/posts/4ce2dba3.html"/>
    <id>https://li199959.github.io/posts/4ce2dba3.html</id>
    <published>2023-04-04T06:47:59.658Z</published>
    <updated>2023-03-29T09:04:56.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-下载完MYSQL后，创建一个新的数据库，然后按下图所示点击：">1.下载完MYSQL后，创建一个新的数据库，然后按下图所示点击：</h3><ol><li>点击查询</li><li>点击新建查询；<br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.1en2sj08sxb4.webp" alt="image"></li></ol><h3 id="2-出现查询的框，我们就可以在框内写入相应代码：">2.出现查询的框，我们就可以在框内写入相应代码：</h3><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.6epy43fkn4g0.webp" alt="image"></p><h3 id="3-font-size-10-增-font-首先对于MYSQL的增删改查来说，我们先说增，这里就举创建一个学生管理的列表：">3. <font size=10><strong>增</strong></font> 首先对于MYSQL的增删改查来说，我们先说增，这里就举创建一个学生管理的列表：</h3><p>具体的语法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表的名字 (</span><br><span class="line">    stuid <span class="type">int</span> not null auto_increment primary key，学生的id <span class="type">int</span>型 自增</span><br><span class="line">    stuname varchar(<span class="number">200</span>), 学生的名称 <span class="number">200</span>表示最多容纳<span class="number">200</span>字符</span><br><span class="line">    stustatus varchar(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">); </span><br><span class="line"># 括号里面可以定义表的属性</span><br></pre></td></tr></table></figure><p>然后按照所学的语法创建一个名为student、grade的表就创建完成</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.57pi3gry4jg0.webp" alt="image"></p><p><strong>需要注意的是，执行程序的时候有键选取执行区域然后就会执行那一小段代码</strong></p><h3 id="4-表格创建完之后，我们要往表格内增添内容，比如添加学生，还有学生的成绩：">4.表格创建完之后，我们要往表格内增添内容，比如添加学生，还有学生的成绩：</h3><p>这里就要用到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into <span class="title function_">student</span><span class="params">(stuname,stustatus)</span> <span class="title function_">values</span> <span class="params">(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;Normal&#x27;</span>)</span></span><br></pre></td></tr></table></figure><p>我们可以看到，student 表格中新建了一个  zhangsan 的数据；</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.73c7zul89n80.webp" alt="image"></p><p>我们再添加几条数据，数据是自增的序号从1往下排，添加grade内数据同样的道理；</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.rz7dgi7swls.webp" alt="image"></p><h3 id="5-font-size-10-删-font-上面是增加的大致内容，下面就介绍一下删除是如何进行的：">5. <font size=10><strong>删</strong></font> 上面是增加的大致内容，下面就介绍一下删除是如何进行的：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delete from 表的名字 ;</span><br><span class="line">delete from student where stuid = <span class="number">1</span>;# 把id为<span class="number">1</span>的学生数据删除</span><br><span class="line">这是delete，还有两种常见的删除 truncate 与 drop</span><br><span class="line">truncate table student；</span><br><span class="line">drop table student</span><br><span class="line">具体的区别是truncate删除完后，再添加新的数据，前面会重新排，不会把<span class="number">123</span>删除了，再加进去一个是从<span class="number">4</span>开始，还是从<span class="number">1</span>开始，然而delete是<span class="number">4</span>开始，它是不重新排的；</span><br></pre></td></tr></table></figure><p>下面是把id=2的学生数据删除，可以从表中可以看到，id=2的学生数据已经被清空，不加后面限制条件，是把所有数据都清空；</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.7910zaocqpg0.webp" alt="image"></p><h3 id="6-font-size-10-改-font-下面介绍一下改的操作">6. <font size=10><strong>改</strong></font> 下面介绍一下改的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 主要就是update</span><br><span class="line">update student <span class="built_in">set</span> stuname=<span class="string">&#x27;zhangsan&#x27;</span>,stustatus = <span class="string">&#x27;Dropped&#x27;</span> where stuid=<span class="number">5</span></span><br><span class="line">#这句话的作用是把id为<span class="number">5</span>的学生姓名，与上学的状态都修改了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是对student中id=1的学生的修改：<br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.5k3cilm0dzc0.webp" alt="image"></p><h3 id="7-font-size-10-查-font-下面是对查询的介绍">7. <font size=10><strong>查</strong></font> 下面是对查询的介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select *from student；</span><br><span class="line"># 不加限制条件是对于整个表的查询</span><br><span class="line">select *from student where stuid =<span class="number">5</span>（后面是要查询的字段）；</span><br><span class="line"># 也可以明确要查询哪个字段</span><br><span class="line">select stuname,stustatus from student where stuid =<span class="number">5</span></span><br><span class="line"># 星号被替换为具体的内容</span><br></pre></td></tr></table></figure><p>下图是查询的几种放式：</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230314/image.32qq4df0bki0.webp" alt="image"></p>]]></content>
    
    
    <summary type="html">一些关于Mysql的基本操作，例如增、删、改、查</summary>
    
    
    
    <category term="mysql" scheme="https://li199959.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown基本语法</title>
    <link href="https://li199959.github.io/posts/47caaf1e.html"/>
    <id>https://li199959.github.io/posts/47caaf1e.html</id>
    <published>2023-04-04T06:47:59.648Z</published>
    <updated>2023-03-23T12:55:10.959Z</updated>
    
    <content type="html"><![CDATA[<p>markdown语法教程:</p><p>一、标题</p><ol><li>#后面加的文字表示一级标题</li><li>##表示二级标题 一般有六级标题</li></ol><h1>标题一</h1><h2 id="二级标题">二级标题</h2><p>二、引用</p><p>引用 &gt;这是一段引用</p><blockquote><p>这是一段引用</p></blockquote><p>三、列表</p><p>有序列表：</p><p>把大象装进冰箱:</p><ol><li>打开冰箱</li><li>把大象放进去</li><li>关上冰箱</li></ol><p>无序列表：</p><ul><li>徐凤年</li><li>温华</li><li>洛阳</li><li>南宫朴耶</li></ul><p>明天要做的事：</p><ul><li><p>[ ] 吃饭</p></li><li><p>[x] 睡觉打豆豆</p></li><li><p>[x] 打豆豆</p></li></ul><p>这个任务列表是可以勾选的</p><p>四、代码块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五、 数学公式<br>$$</p><p>$$<br>六、 表格</p><table><thead><tr><th style="text-align:center">姓名</th><th style="text-align:center">年龄</th><th style="text-align:right">成绩</th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:center">李向彬</td><td style="text-align:center">24</td><td style="text-align:right">100</td><td></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td><td></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td><td></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td><td></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td><td></td><td></td></tr></tbody></table><p>|姓名|年龄|成绩|    这是他的格式</p><p>七、脚注</p><p>一个名词<a href="%E8%BF%99%E4%B8%AA%E5%90%8D%E8%AF%8D%E7%9A%84%E8%A7%A3%E9%87%8A">^注释</a></p><p>文章的结尾可以把这个注释解释一下</p><p>八、横线</p><hr><p>三个 — 表示一个横线</p><p>哈哈哈</p><p>九、链接</p><p><a href="baidu.com">百度</a>’’ 一个搜素哦引擎 ‘’  []里面是链接名字比如’‘百度’‘，后面跟一个英语括号</p><p>还有标题</p><p>请参考<a href="#%E6%A0%87%E9%A2%98%E4%B8%80">标题一</a></p><p>然后ctrl按住标题一就可以跳转</p><p>ulr：<br><a href="http://www.baidu.com">http://www.baidu.com</a></p><p><img src="" alt="百度"></p><p>十、字体格式</p><p>**中间是斜体</p><p><em>斜体</em></p><p>** ** 是加粗</p><p><strong>加粗</strong></p><p>下划线是<u>  </u></p><p><u>xiahuaxian</u></p><p>笑脸是：smile：</p><p>:smile:</p><p>一般公式：</p><p>$\theta=x^2$</p><p>高亮文字 == 中间不能有空格文字==</p><p>==你好==</p><p>X^2^  x^2^</p><p>上标是^^中间是数字</p><p>下标是~~中间是数字</p><p>h~2~0</p><p><img src="./img/2.png" alt="2"></p>]]></content>
    
    
    <summary type="html">文字展示</summary>
    
    
    
    <category term="markdown" scheme="https://li199959.github.io/categories/markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象---类的成员：代码块</title>
    <link href="https://li199959.github.io/posts/125ac875.html"/>
    <id>https://li199959.github.io/posts/125ac875.html</id>
    <published>2023-04-04T06:47:59.619Z</published>
    <updated>2023-03-25T15:59:11.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象—类的成员：代码块">面向对象—类的成员：代码块</h2><p>回顾：类中可以声明的结构：属性、方法、构造器；代码块（或初始化块）、内部类</p><h3 id="代码块（或初始化块）的作用：">代码块（或初始化块）的作用：</h3><p>用来初始化类或对象的信息（即初始化类或对象的成员变量）</p><h3 id="代码块的修饰：">代码块的修饰：</h3><p>只能使用static进行修饰。</p><h3 id="代码块的分类：">代码块的分类：</h3><p>静态代码块：使用static修饰<br>非静态代码块：没有使用static修饰</p><h3 id="具体使用：">具体使用：</h3><p>1 静态代码块：<br>&gt; 随着类的加载而执行<br>&gt; 由于类的加载只会执行一次，进而静态代码块的执行，也只会执行一次<br>&gt; 作用：用来初始化类的信息<br>&gt; 内部可以声明变量、调用属性或方法、编写输出语句等操作。<br>&gt; 静态代码块的执行要先于非静态代码块的执行<br>&gt; 如果声明有多个静态代码块，则按照声明的先后顺序执行<br>&gt; 静态代码块内部只能调用静态的结构（即静态的属性、方法），不能调用非静态的结构（即非静态的属性、方法）</p><p>2 非静态代码块：<br>&gt; 随着对象的创建而执行<br>&gt; 每创建当前类的一个实例，就会执行一次非静态代码块<br>&gt; 作用：用来初始化对象的信息<br>&gt; 内部可以声明变量、调用属性或方法、编写输出语句等操作。<br>&gt; 如果声明有多个非静态代码块，则按照声明的先后顺序执行<br>&gt; 非静态代码块内部可以调用静态的结构（即静态的属性、方法），也可以调用非静态的结构（即非静态的属性、方法）</p>]]></content>
    
    
    <summary type="html">  </summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---static用法</title>
    <link href="https://li199959.github.io/posts/d4e3f3c9.html"/>
    <id>https://li199959.github.io/posts/d4e3f3c9.html</id>
    <published>2023-04-04T06:47:59.615Z</published>
    <updated>2023-03-25T13:15:35.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="static关键字的使用">static关键字的使用</h2><ol><li><p>static: 静态的</p></li><li><p>static 用来修饰的结构：属性、方法; 代码块、内部类；</p></li></ol><h3 id="static修饰属性">static修饰属性</h3><pre><code>复习：变量的分类方式1：按照数据类型：基本数据类型、引用数据类型方式2：按照类中声明的位置：成员变量：按照是否使用static修饰进行分类：使用static修饰的成员变量：静态变量、类变量不使用static修饰的成员变量：非静态变量、实例变量</code></pre><p>局部变量：方法内、方法形参、构造器内、构造器形参、代码块内等。</p><p><strong>回顾类中的实例变量（即非static的成员变量）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.radius=radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个Circle对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Circle c1=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>);<span class="comment">//c1.radius=2.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);<span class="comment">//c2.radius=3.0</span></span><br></pre></td></tr></table></figure><p>Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。</p><p><strong>如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！</strong></p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="static修饰方法">static修饰方法</h3><blockquote><p>随着类的加载而加载<br>可以通过“类.静态方法”的方式，直接调用静态方法<br>静态方法内可以调用静态的属性或静态的方法。（属性和方法的前缀使用的是当前类，可以省略）<br>不可以调用非静态的结构。（比如：属性、方法）</p></blockquote><table><thead><tr><th>类型</th><th>类方法</th><th>实例方法</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table><blockquote><p>static修饰的方法内，不能使用this和super</p></blockquote><blockquote><p>补充：在类的非静态方法中，可以调用当前类中的静态结构（属性、方法）或非静态结构（属性、方法）</p></blockquote><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA中static的用法</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---面向对象，接口</title>
    <link href="https://li199959.github.io/posts/aa6941df.html"/>
    <id>https://li199959.github.io/posts/aa6941df.html</id>
    <published>2023-04-04T06:47:59.613Z</published>
    <updated>2023-03-29T12:57:08.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAva—面向对象（接口）">JAva—面向对象（接口）</h2><h3 id="类比">类比</h3><p>生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？</p><pre><code>USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。</code></pre><p>其实，不管是电脑上的USB插口，还是其他设备上的USB插口都只是<code>遵循了USB规范</code>的一种具体设备而已。</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230325/bbcc80f541000c71b81650cfaa770c86.jdja2eajao8.webp" alt="bbcc80f541000c71b81650cfaa770c86"></p><p>只要设备遵循USB规范的，那么就可以与电脑互联，并正常通信。至于这个设备、电脑是哪个厂家制造的，内部是如何实现的，我们都无需关心。</p><p>Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种<code>面向接口</code>的<code>低耦合</code>，为系统提供更好的可扩展性和可维护性。</p><h3 id="概述">概述</h3><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个&quot;是不是&quot;的is-a关系，而接口实现则是 &quot;能不能&quot;的<code>has-a</code>关系。</p><ul><li>例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或是否具备USB通信功能，就看你能否遵循USB接口规范</li></ul><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230325/image-20220517211517846.5l1m2nz4o0c0.webp" alt="image-20220517211517846"></p><ul><li>例如：Java程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现Java设计的JDBC规范</li></ul><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230325/image-20220325235425916.2ehxv4088qtc.webp" alt="image-20220325235425916"></p><blockquote><p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p></blockquote><h3 id="定义格式">定义格式</h3><p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><blockquote><p>引用数据类型：数组，类，枚举，接口，注解。</p></blockquote><p>接口内部结构的说明：</p><blockquote><p>可以声明：<br>属性：必须使用public static final修饰<br>方法：jdk8之前：声明抽象方法，修饰为public abstract<br>jdk8:声明静态方法、默认方法<br>jdk9:声明私有方法<br>不可以声明：构造器、代码块等</p></blockquote><p>格式：class A extends SuperA implements B,C{}</p><p><strong>A相较于SuperA来讲，叫做子类</strong><br><strong>A相较于B,C来讲，叫做实现类。</strong></p><p>满足此关系之后，说明：</p><blockquote><p>类可以实现多个接口。<br>类针对于接口的多实现，一定程度上就弥补了类的单继承的局限性。<br>类必须将实现的接口中的所有的抽象方法都重写（或实现），方可实例化。否则，此实现类必须声明为抽象类。</p></blockquote><p>接口与接口的关系：继承关系，且可以多继承</p><p>接口的多态性： 接口名 变量名 = new 实现类对象;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的例子</span></span><br><span class="line"><span class="type">fly</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bullet</span>；</span><br><span class="line">f1.fly();<span class="comment">//但是只能调fly中的方法 </span></span><br></pre></td></tr></table></figure><h3 id="实例：">实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(flyable.Minv);</span><br><span class="line">        System.out.println(flyable.Max);</span><br><span class="line">       <span class="comment">// flyable.Minv=1; 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">flyable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> Minv=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">Max</span> <span class="operator">=</span><span class="number">7900</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public static final int Minv=0;前面的public static final是冗余的，可以不加，默认为public static final类型的，所以也不可以更改其属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(flyable.Minv);</span><br><span class="line">        System.out.println(flyable.Max);</span><br><span class="line">        <span class="comment">//flyable.Minv=1;</span></span><br><span class="line">        <span class="type">Bullet</span> <span class="variable">b1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Bullet</span>();</span><br><span class="line">        b1.fly();</span><br><span class="line">        b1.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">flyable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> Minv=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">Max</span> <span class="operator">=</span><span class="number">7900</span>;</span><br><span class="line">    <span class="comment">//方法 前面不用加public abstract</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">attack</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">flyable</span>,attack&#123;</span><br><span class="line"><span class="comment">//类调用接口 要么前面加abstract 或者后面的 对方法进行重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span> <span class="keyword">implements</span> <span class="title class_">flyable</span>,attack&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;让子弹飞一会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子弹可以击穿身体&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题-区分抽象类与接口">面试题 区分抽象类与接口</h3><p>共性：<br>都可以声明抽象方法<br>都不能实例化<br>不同：<br>① 抽象类一定有构造器。接口没有构造器<br>② 类与类之间继承关系，类与接口之间是实现关系，接口与接口之间是多继承关系</p><h3 id="接口练习题">接口练习题</h3><p>一、<br>1、声明接口Eatable，包含抽象方法public abstract void eat();<br>2、声明实现类中国人Chinese，重写抽象方法，打印用筷子吃饭<br>3、声明实现类美国人American，重写抽象方法，打印用刀叉吃饭<br>4、声明实现类印度人Indian，重写抽象方法，打印用手抓饭<br>5、声明测试类EatableTest，创建Eatable数组，存储各国人对象，并遍历数组，调用eat()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">American</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美国人用刀叉吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中国人用筷子吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Indian</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;印度人手抓饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Eatable[] eatables =<span class="keyword">new</span> <span class="title class_">Eatable</span>[<span class="number">3</span>];</span><br><span class="line">        eatables[<span class="number">0</span>] =<span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">        eatables[<span class="number">1</span>] =<span class="keyword">new</span> <span class="title class_">American</span>();</span><br><span class="line">        eatables[<span class="number">2</span>] =<span class="keyword">new</span> <span class="title class_">Indian</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; eatables.length; i++) &#123;</span><br><span class="line">            eatables[i].eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line">中国人用筷子吃饭</span><br><span class="line">美国人用刀叉吃饭</span><br><span class="line">印度人手抓饭</span><br></pre></td></tr></table></figure><p>二、<br>定义一个接口用来实现两个对象的比较。<br>interface CompareObject{<br>//若返回值是 0 , 代表相等; 若为正数，代表当前对象大；负数代表当前对象小<br>public int compareTo(Object o);<br>}</p><ol><li>定义一个Circle类，声明radius属性，提供getter和setter方法<br>定义一个ComparableCircle类，继承Circle类并且实现CompareObject接口。</li><li>在ComparableCircle类中给出接口中方法compareTo的实现体，用来比较两个圆的半径大小。</li><li>定义一个测试类InterfaceTest，创建两个ComparableCircle对象，调用compareTo方法比较两个类的半径大小。</li><li>拓展：参照上述做法定义矩形类Rectangle和ComparableRectangle类，在ComparableRectangle类<br>中给出compareTo方法的实现，比较两个矩形的面积大小。</li></ol>]]></content>
    
    
    <summary type="html">JAVA中接口的总结</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---面向对象，内部类</title>
    <link href="https://li199959.github.io/posts/e9be8b42.html"/>
    <id>https://li199959.github.io/posts/e9be8b42.html</id>
    <published>2023-04-04T06:47:59.609Z</published>
    <updated>2023-03-30T10:18:32.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象—内部类">面向对象—内部类</h2><h3 id="概念">概念</h3><h3 id="实例">实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu09.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: OuterClassTest</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建Person的静态的成员内部类的实例</span></span><br><span class="line">        Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        <span class="comment">//2. 创建Person的非静态的成员内部类的实例</span></span><br><span class="line"><span class="comment">//        Person.Bird bird = new Person.Bird(); //报错</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p1.<span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//正确的</span></span><br><span class="line">        bird.eat();</span><br><span class="line">        bird.show(<span class="string">&quot;黄鹂&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bird.show1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态的成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态的成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;啄木鸟&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;鸟吃虫子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;age = &quot;</span> + age);<span class="comment">//省略了Person.this</span></span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span> + Person.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span>&#123;</span><br><span class="line">            eat();</span><br><span class="line">            <span class="built_in">this</span>.eat();</span><br><span class="line">            Person.<span class="built_in">this</span>.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass1</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass1</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass1</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA中接口的总结</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---面向对象，关键字final</title>
    <link href="https://li199959.github.io/posts/d641d5d1.html"/>
    <id>https://li199959.github.io/posts/d641d5d1.html</id>
    <published>2023-04-04T06:47:59.605Z</published>
    <updated>2023-03-25T15:04:12.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字final的用法">关键字final的用法</h2><h3 id="final关键字的使用">final关键字的使用</h3><ol><li><p>final的理解：最终的</p></li><li><p>final可以用来修饰的结构：类、方法、变量</p></li><li><p>具体说明：</p></li></ol><p>final修饰类：表示此类不能被继承。<br>比如：String、StringBuffer、StringBuilder类</p><p>final修饰方法：表示此方法不能被重写<br>比如：Object类中的getClass()</p><p>final修饰变量：既可以修饰成员变量，也可以修饰局部变量。<br>此时的&quot;变量&quot;其实就变成了&quot;常量&quot;，意味着一旦赋值，就不可更改。</p><p>final修饰成员变量: 有哪些位置可以给成员变量赋值？</p><pre><code>&gt; 显式赋值&gt; 代码块中赋值&gt; 构造器中赋值</code></pre><p>final修饰局部变量：一旦赋值就不能修改</p><pre><code>&gt; 方法内声明的局部变量：在调用局部变量前，一定需要赋值。而且一旦赋值，就不可更改&gt; 方法的形参：在调用此方法时，给形参进行赋值。而且一旦赋值，就不可更改</code></pre><p>final与static搭配：修饰成员变量时，此成员变量称为：全局常量。<br><em>比如：Math的PI</em></p><h3 id="代码举例">代码举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出错 因为无法从final &#x27;finalclass.A&#x27;继承</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为方法前面加了final，是不可以改写的</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">JAVA中关键字final的一些用法</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---ToString()使用</title>
    <link href="https://li199959.github.io/posts/d40039a6.html"/>
    <id>https://li199959.github.io/posts/d40039a6.html</id>
    <published>2023-04-04T06:47:59.602Z</published>
    <updated>2023-03-29T12:56:55.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ToString">ToString()</h2><p>方法签名：public String toString()</p><p>① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式&quot;</p><p>② 在进行String与其它类型数据的连接操作时，自动调用toString()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(“now=”+now);  <span class="comment">//相当于</span></span><br><span class="line">System.out.println(“now=”+now.toString()); </span><br></pre></td></tr></table></figure><p>③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><blockquote><p>因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。</p></blockquote><p>④ 可以根据需要在用户自定义类型中重写toString()方法<br>如String 类重写了toString()方法，返回字符串的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure><p>例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDE的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(u1.toString());<span class="comment">//tostring.User@4554617c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没重写之前输出的是地址值</span></span><br><span class="line">tostring.User@4554617c</span><br></pre></td></tr></table></figure><p>右键生成tostring（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(u1.toString());<span class="comment">//tostring.User@4554617c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果为：User&#123;name=&#x27;tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure><p><strong>题目：</strong><br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230325/%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.rbrqg1gk7mo.webp" alt="类关系图"><br>具体案例需求：<br>定义两个类，父类GeometricObject代表几何形状，子类Circle代表圆形。<br>写一个测试类，创建两个Circle对象，判断其颜色是否相等；利用equals方法判断其半径是否相等；利用toString()方法输出其半径。</p>]]></content>
    
    
    <summary type="html">JAVA中ToString()的用法</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象特征之三：多态性</title>
    <link href="https://li199959.github.io/posts/9747f5d9.html"/>
    <id>https://li199959.github.io/posts/9747f5d9.html</id>
    <published>2023-04-04T06:47:59.600Z</published>
    <updated>2023-03-25T08:29:54.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何理解多态性？">如何理解多态性？</h2><blockquote><p>理解：理解为一个事物的多种形态。</p></blockquote><p>女朋友：我想养一个宠物。<br>孩子：我想要一个玩具。<br>老板：张秘书，安排一个技术科的同事，跟我一起下周出差。</p><blockquote><p>Java中多态性的体现:</p></blockquote><p>子类对象的多态性：父类的引用指向子类的对象。（或子类的对象赋给父类的引用）<br>比如: Person p2 = new Man();</p><blockquote><p>多态性的应用：</p></blockquote><p>多态性的应用：虚拟方法调用<br>在多态的场景下，调用方法时。<br>编译时，认为方法是左边声明的父类的类型的方法（即被重写的方法）<br>执行式，实际执行的是子类重写父类的方法。<br><strong>简称为：编译看左边，运行看右边。</strong></p><blockquote><p>多态性的使用前提：</p></blockquote><p>① 要有类的继承关系<br>② 要有方法的重写</p><blockquote><p>多态的适用性：</p></blockquote><p>适用于方法，不适用于属性。</p><blockquote><p>多态的好处与弊端</p></blockquote><p>弊端：在多态的场景下，我们创建了子类的对象，也加载了子类特有的属性和方法。但是由于声明为父类的引用，导致我们没有办法直接调用子类特有的属性和方法。<br>优点：极大的减少了代码的冗余，不需要定义多个重载的方法。<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>instanceof的使用</p></blockquote><ol><li>建议在向下转型之前，使用instanceof进行判断，避免出现类型转换异常</li><li>格式： a instanceOf A : 判断对象a是否是类A的实例。</li><li>如果a instanceOf A 返回true，则：<br>a instanceOf superA 返回也是true。其中，A 是superA的子类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">  </summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---面向对象，属性赋值的位置及过程</title>
    <link href="https://li199959.github.io/posts/2ec0f7bc.html"/>
    <id>https://li199959.github.io/posts/2ec0f7bc.html</id>
    <published>2023-04-04T06:47:59.596Z</published>
    <updated>2023-03-25T13:13:11.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="赋值的知识总结">赋值的知识总结</h3><p>1.可以给类的非静态的属性（即实例变量）赋值的位置有：<br>① 默认初始化<br>② 显式初始化  或 ⑤ 代码块中初始化<br>③ 构造器中初始化</p><hr><p>④ 有了对象以后，通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方法进行赋值</p><p>2.执行的先后顺序：<br>① - ②/⑤ - ③ - ④</p><p>3.给实例变量赋值的位置很多，开发中如何选？</p><blockquote><p>显示赋值：比较适合于每个对象的属性值相同的场景</p></blockquote><blockquote><p>构造器中赋值：比较适合于每个对象的属性值不相同的场景</p></blockquote><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//技巧：由父及子，静态先行。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line"><span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">+ msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"><span class="comment">//new Leaf();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果为：</span><br><span class="line"></span><br><span class="line">Root的静态初始化块</span><br><span class="line">Mid的静态初始化块</span><br><span class="line">Leaf的静态初始化块</span><br><span class="line">Root的普通初始化块</span><br><span class="line">Root的无参数的构造器</span><br><span class="line">Mid的普通初始化块</span><br><span class="line">Mid的无参数的构造器</span><br><span class="line">Mid的带参数构造器，其参数值：尚硅谷</span><br><span class="line">Leaf的普通初始化块</span><br><span class="line">Leaf的构造器</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA中属性赋值的用法</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---String的构造器和常用方法</title>
    <link href="https://li199959.github.io/posts/ca4a2f74.html"/>
    <id>https://li199959.github.io/posts/ca4a2f74.html</id>
    <published>2023-04-04T06:47:59.593Z</published>
    <updated>2023-04-01T16:16:08.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String的构造器和常用方法">String的构造器和常用方法</h2><h3 id="回顾String与其他结构的转换">回顾String与其他结构的转换</h3><p>1.String与基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    System.out.println(num + <span class="number">1</span>); <span class="comment">//124</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.基本数据类型到String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> String.valueOf(num1);</span><br><span class="line">    System.out.println(str1 + <span class="number">1</span>); <span class="comment">//101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.String到char[ ]的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//String --&gt; char[]:调用String的toCharArray()</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] arr = str1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.char[ ]到String的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr1);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.String到byte[ ]的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="number">5.</span>String到<span class="type">byte</span>[ ]的转换</span><br><span class="line">```java</span><br></pre></td></tr></table></figure><p>5.String到byte[ ]的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="number">5.</span>String到<span class="type">byte</span>[ ]的转换</span><br><span class="line">```java</span><br></pre></td></tr></table></figure><h3 id="构造器">构造器</h3><ul><li><code>public String() </code> ：初始化新创建的 String对象，以使其表示空字符序列。</li><li><code>public String(String original)</code>： 初始化一个新创建的 <code>String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li><li><code>public String(char[] value) </code> ：通过当前参数中的字符数组来构造新的String。</li><li><code>public String(char[] value,int offset, int count) </code> ：通过字符数组的一部分来构造新的String。</li><li><code>public String(byte[] bytes) </code> ：通过使用平台的<strong>默认字符集</strong>解码当前参数中的字节数组来构造新的String。</li><li><code>public String(byte[] bytes,String charsetName) </code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li></ul>]]></content>
    
    
    <summary type="html">JAVA中String的构造器和常用方法</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---字符串不变性与连接操作</title>
    <link href="https://li199959.github.io/posts/c1764609.html"/>
    <id>https://li199959.github.io/posts/c1764609.html</id>
    <published>2023-04-04T06:47:59.589Z</published>
    <updated>2023-04-04T03:29:56.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java—字符串连接操作">java—字符串连接操作</h2><p>String实例化的两种方式<br>第1种方式：String s1 = “hello”;<br>第2种方式：String s2 = new String(“hello”);</p><p>情况1：<br><strong>常量 + 常量:</strong> 结果仍然存储在字符串常量池中，返回此字面量的地址。注：此时的常量可能是字面量，也可能是final修饰的常量<br>情况2：<br><strong>常量 + 变量</strong>  或  <strong>变量 + 变量</strong> ：都会通过new的方式创建一个新的字符串，返回堆空间中此字符串对象的地址<br>情况3：<br>调用字符串的intern():返回的是字符串常量池中字面量的地址</p><p><strong>(了解)</strong> 情况4：concat(xxx):不管是常量调用此方法，还是变量调用，同样不管参数是常量还是变量，总之，调用完concat()方法都返回一个新new的对象。</p><h3 id="示例：">示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringDemo1</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringDemo1</span>();</span><br><span class="line">        sd.test3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//final String s1 = &quot;abc&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>; <span class="comment">//final String s2 = &quot;def&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s4 == s5); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s4 == s6); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s4 == s7); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7); <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//因为s3是常量池中的字符串，s4是堆空间中的字符串，s5是堆空间中的字符串，s6是堆空间中的字符串</span></span><br><span class="line">        <span class="comment">//所以都是false</span></span><br><span class="line">        <span class="comment">//前面加上final的话就是常量池中的字符串 都是true了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AI回答">AI回答</h3><h4 id="GPT">GPT</h4><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230401/image.6mlbrtm871o0.webp" alt="image"><br>回答的还是可以的</p><h4 id="Bard">Bard</h4><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230401/image.5smnjedtfts0.webp" alt="image"><br>感觉没有GPT回答那么成熟外，对这些简单的问题还是可以掌握的。</p><p>顺便再问他有什么要考我的？<br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230401/image.3xmkx5zfqug0.webp" alt="image"><br>拿着这个Bard提的问题去问GPT：<br>我只把一些感兴趣的问答展示一下</p><blockquote><ol><li>Java 中的 == 和 equals() 运算符有什么区别？</li></ol></blockquote><p>Java中的运算==符通过比较两个对象的内存地址来判断它们是否是同一个对象。它检查对象引用是否相等。<br>equals()另一方面，该方法比较两个对象的内容以确定它们是否相等。它检查对象值是否相等。</p><blockquote><ol start="2"><li>什么是字符串池？</li></ol></blockquote><p>字符串池是唯一的、不可变的字符串对象池，由 Java 虚拟机 (JVM) 存储在内存中。当在 Java 程序中使用字符串文字时，JVM 会检查它是否已存在于字符串池中。如果是，则返回对该字符串对象的引用。如果字符串池中不存在，则创建一个新的字符串对象并将其添加到池中。</p><blockquote><ol start="3"><li>你如何检查两个字符串是否相等，忽略大小写？</li></ol></blockquote><p>您可以使用equalsIgnoreCase()方法检查两个字符串是否相等，忽略大小写。此方法在忽略大小写的情况下比较两个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str1.equalsIgnoreCase(str2)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;The strings are equal, ignoring case.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>你会如何反转一个字符串？</li></ol></blockquote><p>您可以使用类在 Java 中反转字符串StringBuilder，该类有一个reverse()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">sb.reverse();</span><br><span class="line"><span class="type">String</span> <span class="variable">reversedStr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(reversedStr); <span class="comment">// prints &quot;dlrow olleh&quot;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="5"><li>你将如何连接两个字符串？</li></ol></blockquote><p>‘+’ 您可以使用运算符或方法在 Java 中连接两个字符串concat()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1.concat(str2);</span><br></pre></td></tr></table></figure><blockquote><ol start="6"><li>你如何将一个字符串拆分成一个字符串数组？</li></ol></blockquote><p>您可以使用 方法将字符串拆分为 Java 中的字符串数组split()。此方法将正则表达式作为参数，并返回一个字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,world,how,are,you&quot;</span>;</span><br><span class="line">String[] parts = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">    System.out.println(part);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会将字符串拆分为一个字符串数组，使用逗号作为分隔符。</p>]]></content>
    
    
    <summary type="html">JAVA中字符串的不变性与连接操作</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程问题</title>
    <link href="https://li199959.github.io/posts/f951b677.html"/>
    <id>https://li199959.github.io/posts/f951b677.html</id>
    <published>2023-04-04T06:47:59.586Z</published>
    <updated>2023-04-01T08:48:47.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程">多线程</h2><p>我们之前学习的程序在没有跳转语句的情况下，都是由上至下沿着一条路径依次执行。现在想要设计一个程序，可以同时有多条执行路径同时执行。比如，<code>一边游戏，一边qq聊天，一边听歌</code>，怎么设计？</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230330/c3dcb61e3b.2o7e0p4u8e80.webp" alt="c3dcb61e3b"></p><h3 id="相关概念">相关概念</h3><blockquote><p>程序、进程与线程</p></blockquote><ul><li><p><strong>程序（program）</strong>：为完成特定任务，用某种语言编写的<code>一组指令的集合</code>。即指<code>一段静态的代码</code>，静态对象。</p></li><li><p><strong>进程（process）</strong>：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。</p><ul><li>每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）</li><li>程序是静态的，进程是动态的</li><li>进程作为<code>操作系统调度和分配资源的最小单位</code>（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。</li><li>现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。</li></ul></li><li><p><strong>线程（thread）</strong>：进程可进一步细化为线程，是程序内部的<code>一条执行路径</code>。一个进程中至少有一个线程。</p><ul><li>一个进程同一时间若<code>并行</code>执行多个线程，就是支持多线程的。</li></ul><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230331/image-20220331233204504.4mj3gah8rte0.webp" alt="image-20220331233204504"></p><ul><li><p>线程作为<code>CPU调度和执行的最小单位</code>。</p></li><li><p>一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code>。</p></li><li><p>下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。<br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230331/image-20220514175737426.44qe295ik680.webp" alt="image-20220514175737426"></p></li></ul><blockquote><p>注意：</p><p>不同的进程之间是不共享内存的。</p><p>进程之间的数据交换和通信的成本很高。</p></blockquote></li></ul><h3 id="多线程程序的优点">多线程程序的优点</h3><p><strong>背景：</strong> 以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？</p><p><strong>多线程程序的优点：</strong></p><ol><li><p>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</p></li><li><p>提高计算机系统CPU的利用率</p></li><li><p>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改<br>单核CPU，在一个时间单元内，只能执行一个线程的任务。例如，可以把CPU看成是医院的医生诊室，在一定时间内只能给一个病人诊断治疗。所以单核CPU就是，代码经过前面一系列的前导操作（类似于医院挂号，比如有10个窗口挂号），然后到cpu处执行时发现，就只有一个CPU（对应一个医生），大家排队执行。</p></li></ol><blockquote><p>这时候想要提升系统性能，只有两个办法，要么提升CPU性能（让医生看病快点），要么多加几个CPU（多整几个医生），即为多核的CPU。</p></blockquote><p><code>问题：多核的效率是单核的倍数吗？</code>譬如4核A53的cpu，性能是单核A53的4倍吗？理论上是，但是实际不可能，至少有两方面的损耗。</p><ul><li><code>一个是多个核心的其他共用资源限制</code>。譬如，4核CPU对应的内存、cache、寄存器并没有同步扩充4倍。这就好像医院一样，1个医生换4个医生，但是做B超检查的还是一台机器，性能瓶颈就从医生转到B超检查了。</li><li><code>另一个是多核CPU之间的协调管理损耗</code>。譬如多个核心同时运行两个相关的任务，需要考虑任务同步，这也需要消耗额外性能。好比公司工作，一个人的时候至少不用开会浪费时间，自己跟自己商量就行了。两个人就要开会同步工作，协调分配，所以工作效率绝对不可能达到2倍。</li></ul><h2 id="创建和启动线程">创建和启动线程</h2><p>Java通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><blockquote><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务</li></ol></blockquote><blockquote><ol start="2"><li>创建Thread子类的实例，即创建了线程对象</li></ol></blockquote><blockquote><ol start="3"><li>调用线程对象的start()方法来启动该线程</li></ol></blockquote>]]></content>
    
    
    <summary type="html">多线程的理解，一些实例</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---Object()使用</title>
    <link href="https://li199959.github.io/posts/2e038d23.html"/>
    <id>https://li199959.github.io/posts/2e038d23.html</id>
    <published>2023-04-04T06:47:59.583Z</published>
    <updated>2023-03-25T08:30:27.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="equals-的使用">equals()的使用</h2><h3 id="适用性：">适用性：</h3><p>任何引用数据类型都可以使用。</p><blockquote><p>java.lang.Object类中equals()的定义：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span> <span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较的是地址关系</span></span><br></pre></td></tr></table></figure><blockquote><p>举例1：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        User u1=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(u1.equals(u2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="comment">// 虽然属性都一样，但是指向的地址不一样。</span></span><br></pre></td></tr></table></figure><h3 id="子类使用说明">子类使用说明</h3><p>自定义的类在没有重写Object中equals()方法的情况下，调用的就是Object类中声明的equals()，比较两个对象的引用地址是否相同。（或比较两个对象是否指向了堆空间中的同一个对象实体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">输出的结果：</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span>  </span><br><span class="line"><span class="comment">//主要原因是str 中重写了 Object() 的用法 </span></span><br></pre></td></tr></table></figure><p><strong>对于像String、File、Date和包装类等，它们都重写了Object类中的equals()方法，用于比较两个对象的实体内容是否相等。</strong></p><h3 id="开发中的使用说明">开发中的使用说明</h3><p>实际开发中，针对于自定义的类，常常会判断两个对象是否equals()，而此时主要是判断两个对象的属性值是否相等。</p><p>所以：我们要重写Object类的equals()方法。</p><p>如何重写:<br>1. 手动自己实现<br>2. 调用IDEA自动实现 <strong>（推荐）</strong><br>IDEA使用：<br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230324/image.58l0egvf18w0.webp" alt="image"><br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230324/image.610u8hfj2580.webp" alt="image"><br><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230324/image.6n7vics09800.webp" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        User u1=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(u1.equals(u2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成后就是下面的形式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="keyword">return</span> age == user.age &amp;&amp; Objects.equals(name, user.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果为</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="高频面试题：-区分-和-equals">高频面试题： 区分 == 和 equals()</h3><p>==：运算符<br>① 使用范围：基本数据类型、引用数据类型<br>② 基本数据类型：判断数据值是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">sout(i1 == i2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">sout(c1 == i3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.0F</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">sout(f1 == i4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>引用数据类型变量：比较两个引用变量的地址值是否相等。（或比较两个引用是否指向同一个对象实体）</p><p>equals()：方法</p><blockquote><p>使用范围：只能使用在引用数据类型上。<br>具体使用：对于类来说，重写equals()和不重写equals()的区别。</p></blockquote>]]></content>
    
    
    <summary type="html">JAVA中Object()的用法</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java面向对象案例</title>
    <link href="https://li199959.github.io/posts/167fe804.html"/>
    <id>https://li199959.github.io/posts/167fe804.html</id>
    <published>2023-04-04T06:47:59.579Z</published>
    <updated>2023-03-24T07:28:08.537Z</updated>
    
    <content type="html"><![CDATA[<h1>学生管理</h1><ol><li>定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</li><li>创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。<br>问题一：打印出3年级(state值为3）的学生信息。<br>问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息<br>提示：<br>（1） 生成随机数：Math.random()，返回值类型double;<br>（2）四舍五入取整：Math.round(double d)，返回值类型long。<br>年级[1,6] : (int)(Math.random() * 6 + 1)<br>分数[0,100] : (int)(Math.random() * 101)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建student类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;number: &quot;</span>+number+<span class="string">&quot; state: &quot;</span>+state+<span class="string">&quot; score: &quot;</span>+score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建第二个类封装类</span></span><br><span class="line"><span class="comment">//1.打印出特定年级的成员</span></span><br><span class="line"><span class="comment">//2.遍历学生信息</span></span><br><span class="line"><span class="comment">//3.对学生进行冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStudentsWithState</span><span class="params">(Student[] students,<span class="type">int</span> state)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; students.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == students[j].state)&#123;</span><br><span class="line">                <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span>students[j];</span><br><span class="line">                <span class="comment">//System.out.println(&quot;number: &quot;+stu.number+&quot; state: &quot;+stu.state+&quot; score: &quot;+stu.score);</span></span><br><span class="line">                System.out.println(stu.show());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStudents</span><span class="params">(Student[] students)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            System.out.println(students[i].show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortStudents</span><span class="params">(Student[] students)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; students.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (students[j].score&gt;students[j+<span class="number">1</span>].score)&#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span>students[j];</span><br><span class="line">                    students[j] =students[j+<span class="number">1</span>];</span><br><span class="line">                    students[j+<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] students =<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">            students[i] =<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            students[i].number=i+<span class="number">1</span>;</span><br><span class="line">            students[i].score=(<span class="type">int</span>)(Math.random() * <span class="number">101</span>);</span><br><span class="line">            students[i].state =(<span class="type">int</span>)(Math.random() * <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; students.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//            if (3 == students[j].state)&#123;</span></span><br><span class="line"><span class="comment">//                Student stu =students[j];</span></span><br><span class="line"><span class="comment">//                //System.out.println(&quot;number: &quot;+stu.number+&quot; state: &quot;+stu.state+&quot; score: &quot;+stu.score);</span></span><br><span class="line"><span class="comment">//                System.out.println(stu.show());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        StudentsUtil util= <span class="keyword">new</span> <span class="title class_">StudentsUtil</span>();</span><br><span class="line">        util.printStudentsWithState(students,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************************************&quot;</span>);</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; students.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(students[i].show());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        util.printStudents(students);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************************************&quot;</span>);</span><br><span class="line">        <span class="comment">//需求2 ：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; students.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for (int j = 0; j &lt; students.length-1-i; j++) &#123;</span></span><br><span class="line"><span class="comment">//                if (students[j].score&gt;students[j+1].score)&#123;</span></span><br><span class="line"><span class="comment">//                    Student temp =students[j];</span></span><br><span class="line"><span class="comment">//                    students[j] =students[j+1];</span></span><br><span class="line"><span class="comment">//                    students[j+1]=temp;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        util.sortStudents(students);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************排序后遍历******************&quot;</span>);</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; students.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(students[i].show());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        util.printStudents(students);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>理解super</h1><p>在Java类中使用super来调用父类中的指定操作：</p><ul><li>super可用于访问父类中定义的属性</li><li>super可用于调用父类中定义的成员方法</li><li>super可用于在子类构造器中调用父类的构造器</li></ul><p>注意：</p><ul><li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li></ul><h2 id="子类构造器中调用父类构造器">子类构造器中调用父类构造器</h2><p>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。</p><p>② 规定：“super(形参列表)”，必须声明在构造器的首行。</p><p>③ 我们前面讲过，在构造器的首行可以使用&quot;this(形参列表)&quot;，调用本类中重载的构造器，<br>结合②，结论：在构造器的首行，“this(形参列表)” 和 &quot;super(形参列表)&quot;只能二选一。</p><p>④ 如果在子类构造器的首行既没有显示调用&quot;this(形参列表)“，也没有显式调用&quot;super(形参列表)”，<br>​     则子类此构造器默认调用&quot;super()&quot;，即调用父类中空参的构造器。</p><p>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>只能是这两种情况之一。</p><p>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了&quot;this(形参列表)“，则剩下的那个一定使用&quot;super(形参列表)”。</p><blockquote><p>开发中常见错误：</p><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则<code>编译出错</code>。</p></blockquote><p>下面是一些方便理解的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interview</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果为</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">AB</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>先执行new B（） 所以先打印 B</li><li>再执行new A（new B） 进入A（B b） 然后执行this</li><li>又来到A（） 执行打印A的操作</li><li>最后回到 打印AB的语句</li></ol><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230323/image.5xeo4x8257w0.webp" alt="image"><br>把这个程序稍微的修改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interview01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把B改为继承于A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">此时的打印结果为：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">AB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230323/image.23l61ewa4g9s.webp" alt="image"></p><h2 id="就近原则">就近原则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interview2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(f.getInfo());</span><br><span class="line">        System.out.println(s.getInfo()); </span><br><span class="line">        s.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s.setInfo(<span class="string">&quot;徐凤年&quot;</span>);</span><br><span class="line">        System.out.println(f.getInfo());</span><br><span class="line">        System.out.println(s.getInfo());</span><br><span class="line">        s.test(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;cpa&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;陈平安&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getInfo());</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出的结果：</span><br><span class="line">第一个 父类里面 ---- cpa</span><br><span class="line">第二个 子类里面没有，还得去父类 ----cpa</span><br><span class="line">s.test()----由于没有getinfo总之得去父类 所以还是 cpa cpa</span><br><span class="line">----------------</span><br><span class="line">s.setInfo(<span class="string">&quot;平安&quot;</span>); 这个需要明白 </span><br><span class="line">System.out.println(f.getInfo()); 上面的修改与f无关，就是迷惑选项 ，应该还是cpa</span><br><span class="line">下面的通过s调用的输出的都是徐凤年</span><br><span class="line">输出结果：</span><br><span class="line">cpa</span><br><span class="line">cpa</span><br><span class="line">cpa</span><br><span class="line">cpa</span><br><span class="line">-----------------</span><br><span class="line">cpa</span><br><span class="line">徐凤年</span><br><span class="line">徐凤年</span><br><span class="line">徐凤年</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对程序稍微修改一下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interview2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(f.getInfo());</span><br><span class="line">        System.out.println(s.getInfo()); </span><br><span class="line">        s.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s.setInfo(<span class="string">&quot;徐凤年&quot;</span>);</span><br><span class="line">        System.out.println(f.getInfo());</span><br><span class="line">        System.out.println(s.getInfo());</span><br><span class="line">        s.test(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;cpa&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;陈平安&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getInfo());</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于子类加了一个重写</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;hexo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*第一个 cpa</span></span><br><span class="line"><span class="comment">  第二个 子类里面的 陈平安</span></span><br><span class="line"><span class="comment">  s.test() this 为陈平安 super cpa</span></span><br><span class="line"><span class="comment">  ------------</span></span><br><span class="line"><span class="comment">  下面的第一个 cpa</span></span><br><span class="line"><span class="comment">  第二个 陈平安</span></span><br><span class="line"><span class="comment">  陈平安</span></span><br><span class="line"><span class="comment">  徐凤年</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">输出结果：</span><br><span class="line">cpa</span><br><span class="line">陈平安</span><br><span class="line">陈平安</span><br><span class="line">cpa</span><br><span class="line">-----------------</span><br><span class="line">cpa</span><br><span class="line">陈平安</span><br><span class="line">陈平安</span><br><span class="line">徐凤年</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA的简单例子</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java学习笔记2</title>
    <link href="https://li199959.github.io/posts/76bf9e42.html"/>
    <id>https://li199959.github.io/posts/76bf9e42.html</id>
    <published>2023-04-04T06:47:59.576Z</published>
    <updated>2023-03-29T09:05:04.152Z</updated>
    
    <content type="html"><![CDATA[<h1>Java对象和多态 （面向对象）</h1><h2 id="面向对象基础">面向对象基础</h2><p>面向对象程序设计(Object Oriented Programming)</p><p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;你输入了：&quot;</span>+str);</span><br><span class="line">sc.close();</span><br></pre></td></tr></table></figure><p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p><p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p><p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p><hr><h2 id="类的基本结构">类的基本结构</h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p><p>类名字一般第一个要大写（规范）</p><h3 id="成员变量">成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.name = <span class="string">&quot;奥利给&quot;</span>;</span><br><span class="line">    System.out.println(test.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员变量默认带有初始值</strong>，也可以自己定义初始值。</p><h3 id="成员方法">成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//Body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><h4 id="方法的定义和使用">方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[返回值类型] 方法名称([参数])&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li><li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li><li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li><li>方法体：方法具体要干的事情</li><li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li></ul><p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//缺少retrun语句！</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">//在循环内返回了！和break区别？</span></span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;淦&quot;</span>);   <span class="comment">//还会到这里吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Test</span>().swap(a, b);</span><br><span class="line">  System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//传递的仅仅是值而已！</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">  a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(B b)</span>&#123;  <span class="comment">//传递的是对象的引用，而不是值</span></span><br><span class="line">    System.out.println(b.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  b.name = <span class="string">&quot;lbw&quot;</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">A</span>().test(b);</span><br><span class="line">  System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法之间可以相互调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//xxxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p><hr><h3 id="对象设计练习">对象设计练习</h3><ul><li>学生应该具有以下属性：名字、年龄</li><li>学生应该具有以下行为：学习、运动、说话</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sports</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在运动！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;: &quot;</span>+word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    s.name=<span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line">    s.age=<span class="number">10</span>;</span><br><span class="line">    s.study();</span><br><span class="line">    s.sports();</span><br><span class="line">    s.speak(<span class="string">&quot;全体目光向我看齐&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230318/image.1dqaem9xon4w.webp" alt="image"></p><hr><h3 id="方法的重载">方法的重载</h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;   <span class="comment">//原本的方法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> i)</span>&#123;  <span class="comment">//ok，形参不同</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">byte</span> i)</span>&#123;  <span class="comment">//ok，返回类型和形参都不同</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;  <span class="comment">//错误，仅返回值类型名称不同不能重载</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//只有int支持，不灵活！</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;  <span class="comment">//重写一个double类型的，就支持小数计算了</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">short</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">long</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">char</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">double</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了double&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">float</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了float&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.a(<span class="number">1</span>);   <span class="comment">//直接输入整数</span></span><br><span class="line">        test.a(<span class="number">1.0</span>);  <span class="comment">//直接输入小数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        test.a(s);  <span class="comment">//会对号入座吗？</span></span><br><span class="line">        test.a(<span class="number">1.0F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法">构造方法</h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译结果</span></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;    <span class="comment">//即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译其实就是把我们编译好的class文件变回Java源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();  <span class="comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span></span><br><span class="line"><span class="comment">// new + 你想要使用的构造方法</span></span><br></pre></td></tr></table></figure><p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p><p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p><p>一般最常用的就是给成员属性赋初始值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    Student()&#123;</span><br><span class="line">        name = <span class="string">&quot;伞兵一号&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;   <span class="comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;  <span class="comment">//通过this指代当前的对象属性，this就代表当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//idea 右键快速生成！</span></span><br></pre></td></tr></table></figure><p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p><p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译后依然只有我们定义的有参构造！</span></span><br></pre></td></tr></table></figure><p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量的初始化始终在构造方法执行之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;sadasa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量和静态方法">静态变量和静态方法</h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;  <span class="comment">//这个变量是共享的 最后结果的输出也是 10 如果不加static输出就不是10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); </span><br><span class="line">s1.a = <span class="number">10</span>;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s2.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   Student.a = <span class="number">10</span>;</span><br><span class="line">   System.out.println(Student.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简述类加载机制">简述类加载机制</h4><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> test();  <span class="comment">//直接调用静态方法，只能调用静态方法</span></span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造类对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;   <span class="comment">//静态方法刚加载时就有了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始化变量a&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p><p>输出的结果是：0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Student.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p><h3 id="代码块和静态代码块">代码块和静态代码块</h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Student.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String和StringBuilder类">String和StringBuilder类</h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p><p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较字符串是否相等，不能直接用 == 而实用下面equal表示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span><span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        System.out.println(str.equals(str2));</span><br><span class="line"><span class="comment">//---------------------------------------------</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;dasdsa&quot;</span>, b = <span class="string">&quot;dasdasdsa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">l</span> <span class="operator">=</span> a+b;</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result=<span class="string">&quot;String&quot;</span>+<span class="string">&quot;and&quot;</span>; <span class="comment">//会被优化成一句！</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;String&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;and&quot;</span>;</span><br><span class="line">String result=str1+str2;</span><br><span class="line"><span class="comment">//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;String&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;and&quot;</span>;</span><br><span class="line">String result=(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(str1))).append(str2).toString();</span><br><span class="line"><span class="comment">//使用StringBuilder，会采用类似于第一种实现，显然会更快！</span></span><br></pre></td></tr></table></figure><p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder</span><br><span class="line">       .append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">       .append(<span class="string">&quot;bc&quot;</span>)</span><br><span class="line">       .append(<span class="string">&quot;d&quot;</span>);   <span class="comment">//链式调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><hr><h2 id="包和访问控制">包和访问控制</h2><h3 id="包声明和导入">包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p><p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p><p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C/C++中的include）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.Student;</span><br></pre></td></tr></table></figure><p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.*</span><br></pre></td></tr></table></figure><p>Java默认为我们导入了以下的包，不需要去声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*</span><br></pre></td></tr></table></figure><h3 id="静态导入">静态导入</h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.test.ui.Student.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态导入不会进行类的初始化！</p><h3 id="访问控制">访问控制</h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230322/image.78i4eb5m5jc0.webp" alt="image"></p><p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//具有私有访问权限，只能类内部访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.println(s.a);  <span class="comment">//还可以访问吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;   <span class="comment">//不能添加权限修饰符！只能是default</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="数组类型">数组类型</h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&amp;refer=http%3A%2F%2Fimgs.itxueyuan.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632192902&amp;t=7a6d67fc01d0e3ea7816adf951c49605" alt="img"></p><p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];  <span class="comment">//需要new关键字来创建！</span></span><br><span class="line">String[] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr.length);   <span class="comment">//数组有成员变量！</span></span><br><span class="line">System.out.println(arr.toString());   <span class="comment">//数组有成员方法！</span></span><br></pre></td></tr></table></figure><h3 id="一维数组">一维数组</h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[数组大小];</span><br><span class="line">类型 变量名称n = <span class="keyword">new</span> 类型[数组大小];  <span class="comment">//支持C语言样式，但不推荐！</span></span><br><span class="line"></span><br><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[]&#123;...&#125;;  <span class="comment">//静态初始化（直接指定值和大小）</span></span><br><span class="line">类型[] 变量名称 = &#123;...&#125;;   <span class="comment">//同上，但是只能在定义时赋值</span></span><br></pre></td></tr></table></figure><p>创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">626</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr.length);  <span class="comment">//打印length成员变量的值</span></span><br></pre></td></tr></table></figure><p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr[<span class="number">10</span>]);  <span class="comment">//出现异常！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span></span><br><span class="line"><span class="comment">//at com.test.Application.main(Application.java:7)</span></span><br></pre></td></tr></table></figure><p>思考：能不能直接修改length的值来实现动态扩容呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr.length = <span class="number">10</span>;<span class="comment">//不可以的 final类型的</span></span><br></pre></td></tr></table></figure><p>重点：数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">2934</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的遍历">数组的遍历</h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p><h4 id="传统for循环">传统for循环</h4><p>我们很容易就联想到for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="foreach">foreach</h4><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p><h3 id="二维数组">二维数组</h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&amp;refer=http%3A%2F%2Ffile.elecfans.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632204192&amp;t=52381354d190d09899776f9bb868ef3e" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三行两列</span></span><br><span class="line"><span class="type">int</span>[][] arr = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">2</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">          System.out.println(arr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组">多维数组</h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p><h3 id="可变长参数">可变长参数</h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     test(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>);    <span class="comment">//可变长，最后都会被自动封装成一个数组</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... test)</span>&#123;</span><br><span class="line">     System.out.println(test[<span class="number">0</span>]);    <span class="comment">//其实参数就是一个数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p><h3 id="实战：三大基本排序算法">实战：三大基本排序算法</h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p><ul><li>冒泡排序 — 细节还是很多的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">   <span class="comment">// System.out.println(arr[2]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="type">boolean</span> b=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>-j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                b =<span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>arr[i];</span><br><span class="line">                arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] =temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230319/image.7gzgiwdf0ik0.webp" alt="image"></p><p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p><ul><li>插入排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j])&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; arr.length; k++) &#123;</span><br><span class="line">            System.out.print(arr[k]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230319/image.3jot3wng99s0.webp" alt="image"></p><p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p><ul><li>选择排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span>arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span>i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&lt;max)&#123;max =arr[j];pos=j;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>arr[i];</span><br><span class="line">        arr[i]=arr[pos];</span><br><span class="line">        arr[pos]=temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p><hr><h2 id="封装、继承和多态">封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><h3 id="封装">封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p><p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含&quot;小&quot;这个字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;小&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p><p>封装就是通过访问权限控制来实现的。</p><h3 id="继承">继承</h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SportsStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;   <span class="comment">//通过extends关键字来继承父类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SportsStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);   <span class="comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exercise</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我超勇的！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArtStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArtStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">art</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;随手画个毕加索！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p><p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p><p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>;</span><br><span class="line">System.out.println(obj.hashCode());  <span class="comment">//求对象的hashcode，默认是对象的内存地址</span></span><br><span class="line">System.out.println(obj.equals(obj));  <span class="comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span></span><br><span class="line">System.out.println(obj.toString());  <span class="comment">//将对象转换为字符串，默认生成对象的类名称+hashcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p><h3 id="多态">多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p><h4 id="方法的重写">方法的重写</h4><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类中的study</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类中的study</span></span><br><span class="line"><span class="meta">@Override</span>  <span class="comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;给你看点好康的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">SportsStudent</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportsStudent</span>(<span class="string">&quot;lbw&quot;</span>, <span class="number">20</span>);</span><br><span class="line">     student.study();   <span class="comment">//输出子类定义的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：静态方法能被重写吗？[   是不可以的  ]</p><p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.study();</span><br><span class="line">    System.out.println(<span class="string">&quot;给你看点好康的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTest</span><span class="params">(<span class="type">int</span> test)</span>&#123;</span><br><span class="line">    test = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.test = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">super</span>.test = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="再谈类型转换">再谈类型转换</h4><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportsStudent</span>(<span class="string">&quot;lbw&quot;</span>, <span class="number">20</span>);  <span class="comment">//父类变量引用子类实例</span></span><br><span class="line">student.study();     <span class="comment">//得到依然是具体实现的结果，而不是当前类型的结果</span></span><br></pre></td></tr></table></figure><p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportsStudent</span>(<span class="string">&quot;lbw&quot;</span>, <span class="number">20</span>);  <span class="comment">//是由SportsStudent进行实现的</span></span><br><span class="line"><span class="comment">//... do something...</span></span><br><span class="line"></span><br><span class="line"><span class="type">SportsStudent</span> <span class="variable">ps</span> <span class="operator">=</span> (SportsStudent)student;  <span class="comment">//让它变成一个具体的子类</span></span><br><span class="line">ps.sport();  <span class="comment">//调用具体实现类的方法</span></span><br></pre></td></tr></table></figure><p>这样的类型转换称为向下转型。</p><h4 id="instanceof关键字">instanceof关键字</h4><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (student <span class="keyword">instanceof</span> SportsStudent)&#123;</span><br><span class="line">        <span class="type">SportsStudent</span> <span class="variable">sportsStudent</span> <span class="operator">=</span> (SportsStudent) student;</span><br><span class="line">        sportsStudent.sport();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (student <span class="keyword">instanceof</span> ArtStudent)&#123;</span><br><span class="line">        <span class="type">ArtStudent</span> <span class="variable">artStudent</span> <span class="operator">=</span> (ArtStudent) student;</span><br><span class="line">        artStudent.art();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p><p>思考：<code>student instanceof Student</code>的结果是什么？</p><h4 id="再谈final关键字">再谈final关键字</h4><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;   <span class="comment">//类被声明为终态，那么它还能被继承吗</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;  <span class="comment">//还能重写吗</span></span><br><span class="line">    System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;   <span class="comment">//引用类型不允许再指向其他对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;    <span class="comment">//基本类型值不允许发生改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p><h4 id="抽象类">抽象类</h4><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;  <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p><p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()&#123;    <span class="comment">//只能直接创建带实现的匿名内部类！</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;   <span class="comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span></span><br><span class="line">    System.out.println(<span class="string">&quot;给你看点好康的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口">接口</h4><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中定义的变量，默认为public static final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SportsStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Eat</span>, ...&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p><p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p><h2 id="内部类">内部类</h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p><h3 id="成员内部类">成员内部类</h3><p>我们的类中可以在嵌套一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;   <span class="comment">//类中定义的一个内部类</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//写法有那么一丝怪异，但是没毛病！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类">静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();   <span class="comment">//不用再创建外部类对象了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类">局部内部类</h3><p>对，你没猜错，就是和局部变量一样哒~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p><h3 id="匿名内部类">匿名内部类</h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eat</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//DO something...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p><h4 id="lambda表达式">lambda表达式</h4><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eat</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//DO something...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> () -&gt; &#123;&#125;;   <span class="comment">//等价于上述内容</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p><p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p><h2 id="枚举类">枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p><p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING, STUDY, SLEEP    <span class="comment">//直接写每个状态的名字即可，分号可以不打，但是推荐打上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举类也非常方便，我们只需要直接访问即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(Status status)</span> &#123;   <span class="comment">//不再是String，而是我们指定的枚举类型</span></span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Status <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compiled from &quot;Status.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.Status <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.test.Status&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status RUNNING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status STUDY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status SLEEP;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING(<span class="string">&quot;睡觉&quot;</span>), STUDY(<span class="string">&quot;学习&quot;</span>), SLEEP(<span class="string">&quot;睡觉&quot;</span>);   <span class="comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">//枚举的成员变量</span></span><br><span class="line">    Status(String name)&#123;    <span class="comment">//覆盖原有构造方法（默认private，只能内部使用！）</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">//获取封装的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类还自带一些继承下来的实用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status.valueOf(<span class="string">&quot;&quot;</span>)   <span class="comment">//将名称相同的字符串转换为枚举</span></span><br><span class="line">Status.values()   <span class="comment">//快速获取所有的枚举</span></span><br></pre></td></tr></table></figure><h2 id="基本类型包装类">基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p><p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><p><img src="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png" alt="img"></p><ul><li>byte  -&gt;  Byte</li><li>boolean  -&gt;  Boolean</li><li>short  -&gt;  Short</li><li>char  -&gt;  Character</li><li>int -&gt; Integer</li><li>long -&gt;  Long</li><li>float -&gt; Float</li><li>double -&gt; Double</li></ul><p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;   <span class="comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span></span><br><span class="line">     System.out.println(i + i);    <span class="comment">//包装类型可以直接被当做一个基本类型进行操作！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动装箱和拆箱">自动装箱和拆箱</h4><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//其实这里只是简写了而已</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);  <span class="comment">//编译后真正的样子</span></span><br></pre></td></tr></table></figure><p>调用valueOf来生成一个Integer对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span></span><br><span class="line">       <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);   <span class="comment">//返回一个新创建好的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i;    <span class="comment">//简写</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i.intValue();   <span class="comment">//编译后实际的代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> i.longValue();   <span class="comment">//其他类型也有！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);   <span class="comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span></span><br><span class="line">    System.out.println(i1.equals(i2));   <span class="comment">//这个才是真正的值判断！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意IntegerCache带来的影响！</p><p>思考：下面这种情况结果会是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1+<span class="number">1</span> == i2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在集合类的学习中，我们还会继续用到我们的包装类型！</p><hr><h2 id="面向对象编程实战">面向对象编程实战</h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;   <span class="comment">//for循环暴力求解，简单，但是效率似乎低了一些</span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println((<span class="number">1</span> + <span class="number">100</span>) * <span class="number">50</span>);  <span class="comment">//高斯求和公式，利用数学，瞬间计算结果！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p><h3 id="对象设计（面向对象、多态运用）">对象设计（面向对象、多态运用）</h3><ul><li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li><li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li><li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li></ul><h3 id="二分搜索（搜索算法）">二分搜索（搜索算法）</h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">26</span>&#125;;   <span class="comment">//测试用例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//请在这里实现搜索算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序（排序算法、递归分治）">快速排序（排序算法、递归分治）</h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p><p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p><h3 id="0-1背包问题（回溯法、剪枝-动态规划优化）">0/1背包问题（回溯法、剪枝/动态规划优化）</h3><p>给定 <code>n </code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] w = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] v = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java对象和多态，面向对象</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java基础语法</title>
    <link href="https://li199959.github.io/posts/fd6cf457.html"/>
    <id>https://li199959.github.io/posts/fd6cf457.html</id>
    <published>2023-04-04T06:47:59.571Z</published>
    <updated>2023-03-24T07:28:04.089Z</updated>
    
    <content type="html"><![CDATA[<h1>Java语法规范</h1><p>所有的Java语句必须以<code>;</code>结尾！</p><p>无论是<code>()</code>、<code>[]</code>还是<code>&#123;&#125;</code>，所有的括号必须一一匹配！</p><p>主方法的代码只能写在<code>&#123;&#125;</code>中！</p><h1>Java基础语法（面向过程）</h1><p>在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！</p><h2 id="变量和关键字">变量和关键字</h2><h3 id="变量">变量</h3><p>变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">a = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解）</p><p>变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C+±-</p><p>Java是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！）</p><p>定义一个变量的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[类型] [标识符(名字)] = [初始值(可选)]</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>注意：标识符不能为以下内容：</p><ul><li>标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>大小写敏感！</li><li>不能有空格、@、#、+、-、/ 等符号</li><li>应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头</li><li>不可以是 true 和 false</li><li>不能与Java语言的关键字重名</li></ul><h3 id="关键字">关键字</h3><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230315/image.6xyqnh903r00.webp" alt="image"></p><p>包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！</p><h3 id="常量">常量</h3><p>常量就是无法修改值的变量，常量的值，只能定义一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">10</span>;  <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure><p>常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！）</p><p>这只是final关键字的第一个用法，后面还会有更多的用法。</p><h3 id="注释">注释</h3><p>养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我是</span></span><br><span class="line"><span class="comment">* 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 待做标记</span></span><br></pre></td></tr></table></figure><hr><h2 id="基本数据类型">基本数据类型</h2><p>Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。</p><p>这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了）</p><h3 id="计算机中的二进制表示">计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 =&gt; 0</li><li>最大：1111 =&gt; 2^3+2^2+2^1+2^0 =&gt; 8 + 4 + 2 + 1 = 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 =&gt; -(2^2+2^1+2^0) =&gt; -7</li><li>最大：0111 =&gt; +(2^2+2^1+2^0) =&gt; +7 =&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。</p><h3 id="计算机中的加减法">计算机中的加减法</h3><h4 id="原码">原码</h4><p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p><p>我们得创造一种更好的表示方式！于是我们引入了反码：</p><h4 id="反码">反码</h4><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p><ul><li>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</li></ul><h4 id="补码">补码</h4><p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li></ul><p>其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p><p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p><p>所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）</p><p><code>以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解</code></p><hr><h3 id="整数类型">整数类型</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型！</li><li>long 长整形（64个bit，也就是8个字节）最后需要添加l或L</li></ul><p>long都装不下怎么办？BigInteger！</p><p>数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例：</p><p>0111 + 0001 = 1000 =&gt;  -8（你没看错，就是这样！）</p><p>整数还能使用8进制、16进制表示：</p><ul><li>十进制为15 = 八进制表示为017 = 十六进制表示为 0xF = 二进制表示 1111 (代码里面不能使用二进制！)</li></ul><h3 id="字符类型和字符串">字符类型和字符串</h3><p>在Java中，存在字符类型，它能够代表一个字符：</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535</li><li>使用Unicode表示就是：\u0000 ~ \uffff</li></ul><p>字符要用单引号扩起来！比如 char c = ‘淦’;</p><p>字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符<code>'A'</code>的ASCII码就是数字<code>65</code>，所以，char类型其实可以转换为上面的整数类型。</p><p>Java的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名）</p><p>既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解）</p><p>String就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。</p><p>字符串用双引号括起来！比如：String str = “一日三餐没烦恼”;</p><h3 id="小数类型">小数类型</h3><p>小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的：</p><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230316/6fcd1bb33c084a6399dfb2035ddc175a.3dy8bhl1f2y0.webp" alt="6fcd1bb33c084a6399dfb2035ddc175a"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>V = (-1)^S × M × 2^E<br>（1）(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。<br>（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）<br>（3）2^E 表示指数位。（用于移动小数点）</p><p>比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。</p><p>思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！</p><h3 id="布尔类型">布尔类型</h3><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><hr><h2 id="类型转换">类型转换</h2><h3 id="隐式类型转换">隐式类型转换</h3><p>隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下：</p><ul><li>byte→short(char)→int→long→float→double</li></ul><p>问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！</p><p>所以，如下的代码就能够正常运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> b;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> f;</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 9.0</span></span><br></pre></td></tr></table></figure><h3 id="显示类型转换">显示类型转换</h3><p>显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 -128</span></span><br></pre></td></tr></table></figure><p>为什么结果是-128？精度丢失了！</p><ul><li>int 类型的128表示：00000000 00000000 00000000 10000000</li><li>byte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 =&gt; -128</li></ul><h3 id="数据类型自动提升">数据类型自动提升</h3><p>在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">105</span>;</span><br><span class="line">b = b + <span class="number">1</span>;   <span class="comment">//报错！</span></span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p>这个特性是由 <strong>Java虚拟机规范</strong> 定义的，也是为了提高运行的效率。其他的特性还有：</p><ul><li>如果一个操作数是long型，计算结果就是long型</li><li>如果一个操作数是float型，计算结果就是float型</li><li>如果一个操作数是double型，计算结果就是double型</li></ul><hr><h2 id="运算符">运算符</h2><h3 id="赋值和算术运算符">赋值和算术运算符</h3><p>赋值运算符<code>=</code>是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>算术运算符也就是我们在小学阶段学习的<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>，分别代表加减乘除还有取余，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;</span><br><span class="line"><span class="comment">//结果为6</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>+</code>还可以用作字符串连接符使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;lbw&quot;</span> + <span class="string">&quot;nb&quot;</span>);  <span class="comment">//lbwnb</span></span><br></pre></td></tr></table></figure><p>当然，字符串可以直接连接其他类型，但是会全部当做字符串处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;lbw&quot;</span> + a + b); <span class="comment">//lbw715</span></span><br></pre></td></tr></table></figure><p>算术运算符还包括<code>++</code>和<code>--</code>也就是自增和自减，以自增为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line">System.out.println(a); <span class="comment">//输出为11</span></span><br></pre></td></tr></table></figure><p>自增自减运算符放在变量的前后的返回值是有区别的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a++);  <span class="comment">//10 （先返回值，再自增）</span></span><br><span class="line">System.out.println(a);   <span class="comment">//11</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(++a);  <span class="comment">//11 （先自增，再返回值）</span></span><br><span class="line">System.out.println(a);  <span class="comment">//11</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(b+++a++);  <span class="comment">//猜猜看结果是多少</span></span><br></pre></td></tr></table></figure><p>根据运算符优先级，先执行后缀自增运算符（++）的操作，然后执行加法运算符（+）的操作。因此，该语句的执行顺序如下：<br>b 的值为 2，它被打印出来。</p><ul><li><p>b 的值被加 1，现在 b 的值为 3。</p></li><li><p>a 的值为 10，它被加到 b 的值上，现在 b 的值为 13。</p></li><li><p>a 的值被加 1，现在 a 的值为 11。</p></li></ul><p>因此，该语句的结果为 12（即 2 + 10），并且变量 a 和 b 的值分别为 11 和 3。</p><p>为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括<code>+=</code>、<code>-=</code>、<code>/=</code>、<code>*=</code>、<code>%=</code>，和自增自减类似，先执行运算，再返回结果，同时自身改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a += <span class="number">2</span>);  <span class="comment">//等价于 a = a + 2</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符">关系运算符</h3><p>关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt; == <span class="comment">//大于小于等于</span></span><br><span class="line">&gt;= &lt;=  !=  <span class="comment">//大于等于，小于等于，不等于</span></span><br></pre></td></tr></table></figure><p>关系运算符一般只用于基本类型的比较，运算结果只能是boolean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">//结果为 true</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符">逻辑运算符</h3><p>逻辑运算符两边只能是boolean类型或是关系/逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; <span class="comment">//与运算，要求两边同时为true才能返回true</span></span><br><span class="line">|| <span class="comment">//或运算，要求两边至少要有一个为true才能返回true</span></span><br><span class="line">! <span class="comment">//非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span></span><br></pre></td></tr></table></figure><p>实际案例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b &amp;&amp; a &lt; b;  <span class="comment">//怎么可能同时满足呢</span></span><br><span class="line">System.out.println(x);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b || a &lt;= b;  <span class="comment">//一定有一个满足！</span></span><br><span class="line">System.out.println(x);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> !(a &gt; b); <span class="comment">//对结果进行反转，本来应该是true</span></span><br><span class="line">System.out.println(x); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="位运算符">位运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; <span class="comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span></span><br><span class="line">| <span class="comment">//按位或</span></span><br><span class="line">^ <span class="comment">//按位异或 0 ^ 0 = 0</span></span><br><span class="line">~ <span class="comment">//按位非</span></span><br></pre></td></tr></table></figure><p>按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例：</p><p>0101 &amp; 0100 = 0100 （只有同时为1对应位才得1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(a &amp; b); <span class="comment">//结果为7</span></span><br></pre></td></tr></table></figure><h3 id="三目运算符">三目运算符</h3><p>三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a &gt; b ? <span class="string">&quot;行&quot;</span> : <span class="string">&quot;不行&quot;</span>;  <span class="comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 </span></span><br><span class="line">System.out.println(<span class="string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="comment">//汉堡做的行不行？不行</span></span><br></pre></td></tr></table></figure><p>理解三目运算符，就很容易理解后面的if-else语句了。</p><hr><h2 id="流程控制">流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><h3 id="选择结构">选择结构</h3><p>选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。</p><h4 id="if语句">if语句</h4><p>就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">  <span class="comment">//判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//判断失败执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if的内容执行完成后，后面的内容正常执行</span></span><br></pre></td></tr></table></figure><p>其中，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//再次判断，如果判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//上面的都没成功，只能走这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//前提是判断条件1要成功才能进来！</span></span><br><span class="line">  <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//判断成功执行的内容</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//判断失败执行的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch语句">switch语句</h4><p>我们不难发现，虽然<code>else-if</code>能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(判断主体)&#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！</p><p>为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！</p><h3 id="循环结构">循环结构</h3><p>小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？</p><h4 id="for语句">for语句</h4><p>for语句是比较灵活的循环控制语句，一个for语句的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件;循环条件;更新)&#123;</span><br><span class="line">  <span class="comment">//循环执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后，继续执行</span></span><br></pre></td></tr></table></figure><ul><li>初始条件：循环开始时的条件，一般用于定义控制循环的变量。</li><li>循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。</li><li>更新：每轮循环结束后都会执行的内容，一般写增量表达式。</li></ul><p>初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">520</span>;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">//这里的内容将会永远地进行下去！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强for循环在数组时再讲解！</p><h4 id="while循环">while循环</h4><p>while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">  <span class="comment">//循环执行的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//执行内容</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><p>一定会先执行do里面的内容，再做判断！</p><p>思考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它们的性能谁更高？</span></span><br></pre></td></tr></table></figure><hr><h2 id="面向过程编程实战（基础-算法）">面向过程编程实战（基础+算法）</h2><h3 id="打印九九乘法表">打印九九乘法表</h3><p>简单：将九九乘法表打印到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        System.out.print(j + <span class="string">&quot; x &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (i*j) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加 \t 的作用：在上面打印 99 乘法表时，我们在乘积之间加上了 \t，这样输出时就会在每个乘积之间插入一个制表符，使得输出的内容在水平方向上保持对齐。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230317/image.4wa4blunc8i0.webp" alt="image"></p><h3 id="求1000以内的水仙花数">求1000以内的水仙花数</h3><p>中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 = 1^3 + 5^3 + 3^3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,a,b,c,shuixian;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">100</span>;i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">    a = i/<span class="number">100</span>;</span><br><span class="line">    b = i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">    c = i%<span class="number">10</span>;</span><br><span class="line">    shuixian = a*a*a +b*b*b+c*c*c;</span><br><span class="line">    <span class="keyword">if</span> (shuixian == i)&#123;</span><br><span class="line">        System.out.println(i+<span class="string">&quot;是水仙花&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230317/image.4uf2dn1l5ds0.webp" alt="image"></p><h3 id="青蛙跳台阶问题">青蛙跳台阶问题</h3><p>困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p><strong>这个问题类似费波纳列序列</strong></p><p><strong>动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>[] arr =<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">    arr[i]=arr[i-<span class="number">1</span>]+arr[i-<span class="number">2</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;阶有&quot;</span>+arr[i]+<span class="string">&quot;种走法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/li199959/imgbed@main/20230317/image.yjbkoj92qi8.webp" alt="image"></p><hr><p>不对啊，别的教程都讲了数组、方法，怎么我们还没讲就进入面向对象了呢？</p><ul><li>数组在Java中，并非基本类型，数组是编程不可见的对象类型，学习了面向对象再来理解，会更加容易！</li><li>方法在Java中是类具有的属性，所以，在了解了对象类型之后，再来了解方法，就更加简单了！</li></ul>]]></content>
    
    
    <summary type="html">JAVA的语法规范</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java---API-Spring</title>
    <link href="https://li199959.github.io/posts/537d2a3e.html"/>
    <id>https://li199959.github.io/posts/537d2a3e.html</id>
    <published>2023-04-04T06:47:59.541Z</published>
    <updated>2023-03-30T10:22:55.726Z</updated>
    
    
    <summary type="html">JAVA中接口的总结</summary>
    
    
    
    <category term="Java" scheme="https://li199959.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
